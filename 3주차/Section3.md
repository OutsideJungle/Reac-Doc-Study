## Section 3. Adding Interactivity

<br>

1. [사용자 이벤트를 처리하는 방법](#1-이벤트에-응답하기)
2. [컴포넌트가 state를 이용하여 정보를 "기억"하는 방법](#2-state--컴포넌트의-기억-저장소)
3. [React가 UI를 업데이트하는 두 가지 단계](#3-렌더링-그리고-커밋)
4. [state가 변경된 후 바로 업데이트되지 않는 이유](#4-스냅샷으로서의-state)
5. [여러 개의 state 업데이트를 대기열에 추가하는 방법](#5-state-업데이트-큐)
6. [state에서 객체를 업데이트하는 방법](#6-객체-state-업데이트하기)
7. [state에서 배열을 업데이트하는 방법](#7-배열-state-업데이트하기)

<br>

### 1. 이벤트에 응답하기

- **이벤트 핸들러** : 클릭, 마우스 호버, 폼 인풋 포커스 등 사용자 상호작용에 따라 유발되는 사용자 정의 함수
- `<button>`과 같은 내장 컴포넌트는 `onClick`과 같은 내장 브라우저 이벤트만 지원
- 반면, 사용자 정의 컴포넌트를 생성하는 경우, 컴포넌트 이벤트 핸들러 props의 역할에 맞는 원하는 이름 사용 가능

<br>

#### 이벤트 핸들러 함수
```javascript
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```
- `handleClick` 함수를 정의한 후 `<button>`에 **prop 형태로 전달**
- 여기서 `handleClick` 함수는 이벤트 핸들러 함수
- 이벤트 핸들러 함수는 주로 컴포넌트 내부에서 정의됨
- 또한, `handle`로 시작하고 그 뒤에 이벤트명을 붙인 함수명을 가짐

<br>

💡 **인라인 함수**나 **화살표 함수**를 사용하여 보다 간결하게 정의 가능
```javascript
<button onClick={function handleClick() {
  alert('You clicked me!');
}}>
```
```javascript
<button onClick={() => {
  alert('You clicked me!');
}}>
```

<br>

#### 이벤트 전파
- 이벤트 핸들러는 해당 컴포넌트가 가진 어떤 자식 컴포넌트의 이벤트를 수신할 수 있음
- 이를 이벤트가 트리를 따라 **"bubble"**되거나 **"전파된다"**고 표현
- 이 때 이벤트는 발생한 지점에서 시작하여 트리를 따라 위로 전달

<br>

```javascript
export default function Toolbar() {
  return (
    <div className="Toolbar" onClick={() => {
      alert('You clicked on the toolbar!');
    }}>
      <button onClick={() => alert('Playing!')}>
        Play Movie
      </button>
      <button onClick={() => alert('Uploading!')}>
        Upload Image
      </button>
    </div>
  );
}
```
- 둘 중 어느 버튼을 클릭하더라도 해당 버튼의 `onClick` 먼저 실행 후 부모 `<div>`의 `onClick` 실행
- 만약 ToolBar 자체를 클릭한다면 부모 `<div>`의 `onClick`만 실행
- 이벤트가 부모 컴포넌트에 닿지 못하도록 막으려면 `e.stopPropagation()` 호출

<br>

#### 기본 동작 방지하기
- 일부 브라우저 이벤트는 그와 관련된 기본 브라우저 동작을 가짐
- 이를 방지하기 위해 `e.preventDefault()`를 이벤트 오브젝트에서 호출

💡 **`e.stopPropagation()` vs `e.preventDefault()`**
- `e.stopPropagation()`은 이벤트 핸들러가 상위 태그에서 실행되지 않도록 멈춤
- `e.preventDefault()`는 기본 브라우저 동작을 가진 일부 이벤트가 해당 기본 동작을 실행하지 않도록 방지

<br>

### 2. State : 컴포넌트의 기억 저장소

#### State를 사용하는 이유?
- **일반 변수로 충분하지 않음**
  1. 지역 변수는 렌더링 간에 유지되지 않음 -> React는 컴포넌트를 두 번째로 렌더링할 때 지역 변수에 대한 변경 사항은 고려하지 않고 처음부터 렌더링 함
  2. 지역 변수를 변경해도 렌더링을 일으키지 않음 -> React는 새로운 데이터로 컴포넌트를 다시 렌더링해야 한다는 것을 인식하지 못함
- **컴포넌트를 새로운 데이터로 업데이트하기 위해선 다음 두 가지가 필요**
  1. 렌더링 사이에 데이터를 **유지**
  2. React가 새로운 데이터로 컴포넌트를 렌더링하도록 **유발**
- **useState 훅은 다음 두 가지를 제공**
  1. 렌더링 간에 데이터를 유지하기 위한 **state 변수**
  2. 변수를 업데이트하고 React가 컴포넌트를 다시 렌더링하도록 유발하는 **state setter 함수**

<br>

#### `useState` 해부하기
`useState`와 같이 "`use`"로 시작하는 다른 모든 함수를 훅이라고 함. 이 훅은 **컴포넌트의 최상위 수준** 또는 **커스텀 훅**에서만 호출 가능

```javascript
const [index, setIndex] = useState(0);
```
컴포넌트가 렌더링될 때마다, `useState`는 다음 두 개의 값을 포함하는 배열을 제공
1. 저장한 값을 가진 **state 변수** (`index`)
2. state 변수를 업데이트하고 React에 컴포넌트를 다시 렌더링하도록 유발하는 **state setter 함수** (`setIndex`)

<br>

##### 📎 작동 방식
1. **컴포넌트가 처음 렌더링** 
   - `index`의 초기값으로 `useState`를 사용해 `0`을 전달했으므로 `[0, setIndex]` 반환
2. **state를 업데이트**
   - 사용자가 버튼을 클릭하면 `setIndex(index + 1)` 호출
   - React에 `index`가 1임을 기억하게 하고 또 다른 렌더링 유발
3. **컴포넌트가 두 번째로 렌더링**
   - React는 `index`를 1로 설정한 것을 기억하고 있기 때문에, 이번에는 `[1, setIndex]` 반환
4. 위의 과정이 반복

<br>

#### State는 격리되고 비공개로 유지
- State는 화면에서 컴포넌트 인스턴스에 지역적
- 즉, 동일한 컴포넌트를 두 번 렌더링한다면 각 복사본은 **완전히 격리된 state**를 가짐
- State는 특정 함수 호출이나 코드 내의 특정 위치와 관련이 없음
- Props와 달리 **state는 선언한 컴포넌트에 완전히 비공개**
- 만약, state 간 동기화를 원한다면, state를 **가장 가까운 공통 부모 컴포넌트**에 추가하는 것

<br>

### 3. 렌더링 그리고 커밋
#### UI를 요청하고 제공하는 3가지 단계
1. 렌더링 트리거 (손님의 주문을 주방으로 전달)
2. 컴포넌트 렌더링 (주방에서 주문 준비하기)
3. DOM에 커밋 (테이블에 주문한 요리 내놓기)

<br>

#### 1단계 - 렌더링 트리거
📎 **컴포넌트 렌더링이 일어나는 이유**
1. 컴포넌트의 초기 렌더링인 경우
2. 컴포넌트의 state가 업데이트된 경우

##### 초기 렌더링
- 앱을 시작할 때 초기 렌더링을 트리거
- 대상 DOM 노드와 함께 `createRoot`를 호출한 다음 해당 컴포넌트로 `render` 메서드를 호출

##### State 업데이트 시 리렌더링
- 컴포넌트가 처음으로 렌더링 된 후에는 set 함수를 통해 상태를 업데이트하여 추가적인 렌더링을 트리거
- 컴포넌트의 상태를 업데이트하면 자동으로 렌더링 대기열에 추가

<br>

#### 2단계 - React 컴포넌트 렌더링
렌더링을 트리거한 후 React는 컴포넌트를 호출하여 화면에 표시할 내용 파악. 
"렌더링" React에서 컴포넌트를 호출하는 것
- 초기 렌더링에서 React는 루트 컴포넌트를 호출
- 이후 렌더링에서 React는 state 업데이트가 일어나 렌더링을 트리거한 컴포넌트 호출

💡 **재귀적 단계** : 업데이트 된 컴포넌트가 다른 컴포넌트를 반환하면 React는 다음으로 해당 컴포넌트를 렌더링하고 
해당 컴포넌트도 컴포넌트를 반환하면 반환된 컴포넌트를 다음에 렌더링하는 방식
- 초기 렌더링 하는 동안 React는 각 태그에 대한 DOM 노드 생성
- 리렌더링하는 동안 React는 이전 렌더링 이후 변경된 속성 계산
- 다음 단계인 커밋 단계까지는 해당 정보로 아무런 작업도 수행하지 않음

💡 **렌더링은 항상 순수한 계산**
- 동일한 입력에는 동일한 출력을 해야 함
  - 동일한 입력이 주어지면 컴포넌트는 항상 동일한 JSX 반환
- 이전의 state를 변경해서는 안됨
  - 렌더링 전에 존재했던 객체나 변수를 변경해서는 안됨

<br>

#### 3단계 - React가 DOM에 변경사항을 커밋
컴포넌트를 렌더링한 후 React는 DOM을 수정
- **초기 렌더링의 경우** React는 `appendChild()` DOM API를 사용하여 생성한 모든 DOM 노드를 화면에 표시
- **리렌더링의 경우** React는 필요한 최소한의 작업(렌더링하는 동안 계산된 것)을 적용하여 DOM이 최신 렌더링 출력과 일치하도록 함

**React는 렌더링 간에 차이가 있는 경우에만 DOM 노드를 변경**

<br>

### 4. 스냅샷으로서의 State
**"렌더링"**이란 React가 컴포넌트, 즉 함수를 호출한다는 뜻이다.
해당 함수에서 반환하는 JSX는 시간상 **UI의 스냅샷**과 같다.
prop, 이벤트 핸들러, 로컬 변수는 모두 **렌더링 당시의 state**를 사용해 계산된다.

사진이나 동영상 프레임과 달리 반환하는 UI "스냅샷"은 **대화형**이다.
React는 이 스냅샷과 일치하도록 **화면을 업데이트하고 이벤트 핸들러를 연결**한다.

**React가 컴포넌트를 다시 렌더링할 때.**
1. React가 함수를 다시 호출
2. 함수가 새로운 JSX 스냅샷을 반환
3. 그러면 React가 함수가 반환한 스냅샷과 일치하도록 화면을 업데이트

📎 **React가 함수 호출 -> 스냅샷 계산 -> DOM tree 업데이트**

<br>

컴포넌트의 메모리로써 state는 함수가 반환된 후 사라지지 않고 React 자체에 존재

📎 **React에 state를 업데이트하라고 명령 -> React가 state 값을 업데이트 -> React는 상태 값의 스냅샷을 컴포넌트에 전달**

- state를 설정하면 다음 렌더링에 대해서만 변경됨
- state 변수의 값은 이벤트 핸들러의 코드가 비동기적이더라도 렌더링 내에서 절대 변경되지 않음
- React는 렌더링의 이벤트 핸들러 내에서 state 값을 "고정"으로 유지

<br>

### 5. state 업데이트 큐
💡 React는 state 업데이트를 하기 전에 이벤트 핸들러의 모든 코드가 실행될 때까지 기다린다.
- 이를 통해 너무 많은 리렌더링이 발생하지 않고도 여러 컴포넌트에서 나온 **다수의 state 변수를 업데이트** 가능
- **batching**이라고도 하는 이 동작은 React 앱을 훨씬 빠르게 실행할 수 있게 해줌
- React는 클릭과 같은 **여러 의도적인 이벤트에 대해 batch를 수행하지 않으며**, 각 클릭은 개별적으로 처리됨

<br>

💡 이벤트 핸들러가 완료되면 React는 리렌더링을 실행
- 리렌더링하는 동안 React는 **state 큐를 순회**함
- 업데이터 함수는 렌더링 중에 실행되므로, **업데이터 함수는 순수해야 하며 결과만 반환**해야 함
- 업데이터 함수 내부에서 state를 변경하거나 다른 사이드 이펙트를 실행하면 X

<br>

### 6. 객체 State 업데이트하기
state에 저장한 자바스크립트 객체는 어떤 것이라도 **읽기 전용**인 것처럼 다루어야 한다.
- 변경은 이미 state에 존재하는 객체를 변경할 때 문제가 됨
- But, 방금 만든 객체를 수정하는 것은 아직 다른 코드가 해당 객체를 참조하지 않기 때문에 괜찮음
- 이를 "지역 변경"이라고 함. 렌더링하는 동안 지역 변경은 가능

<br>

#### 전개 문법으로 객체 복사하기
- 새로 생성하는 객체에 존재하는 데이터를 포함하고 싶을 때, `...` 전개 문법 사용
- 전개 문법은 '얕다'. 즉, 한 레벨 깊이의 내용만 복사
- 빠르지만, 중첩된 프로퍼티를 업데이트하고 싶다면 한 번 이상 사용해야 함
```javascript
function handleChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value
    });
  }
```

<br>

#### Immer로 간결한 갱신 로직 작성하기
- Immer가 제공하는 `draft`는 **Proxy**라고 하는 아주 특별한 객체 타입으로, 당신이 하는 일을 **"기록"**
- Immer는 내부적으로 `draft`의 어느 부분이 변경되었는지 알아내어, **변경사항을 포함한 완전히 새로운 객체 생성**
- Immer는 업데이트 핸들러를 간결하게 관리할 수 있는 좋은 방법이며, 특히 state가 중첩되어 있고 객체를 복사하는 것이 중복되는 코드를 만들 때 유용
```javascript
const [person, updatePerson] = useImmer({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });
```

<br>

#### 💡 왜 리엑트에서 state 변경은 권장되지 않는가?
1. **디버깅**
   - 만약 `console.log`를 사용하고 state를 변경하지 않는다면, 과거 로그들은 가장 최근 state 변경 사항들에 의해 지워지지 않음
   - 따라서 state가 렌더링 사이에 어떻게 바뀌었는지 명확하게 알 수 있음
2. **최적화**
   - 보편적인 리액트 최적화 전략은 이전 props 또는 state가 다음 것과 동일할 때 일을 건너뛰는 것에 의존
   - state를 절대 변경하지 않는다면 변경사항이 있었는지 확인하는 작업이 매우 빨라짐 
   - `prevObj === obj`를 통해 내부적으로 아무것도 바뀌지 않았음을 확인 가능
3. **새로운 기능**
   - 우리가 만드는 새로운 리액트 기능들은 스냅샷처럼 다루어지는 것에 의존
   - 만약 state의 과거 버전을 변경한다면, 새로운 기능을 사용하지 못할 수 있음
4. **요구사항 변화**
   - 취소/복원 구현, 변화 내역 조회, 사용자가 이전 값으로 폼을 재설정하기 등의 기능은 아무것도 변경되지 않았을 때 더 쉬움
   - 왜냐하면 당신은 메모리에 state의 이전 복사본을 저장하여 적절한 상황에 다시 사용할 수 있기 때문
5. **더 간단한 구현**
   - 리액트는 변경에 의존하지 않기 때문에 객체로 뭔가 특별한 것을 할 필요가 없음
   - 프로퍼티를 가져오거나, 항상 프록시로 감싸거나, 다른 많은 “반응형” 솔루션이 그러듯 초기화 시에 다른 작업을 하지 않아도 됨

<br>

### 7. 배열 State 업데이트하기
- 객체와 마찬가지로 React state에서 배열은 읽기 전용으로 처리해야 함
- 배열을 업데이트 할 때마다 새 배열을 state 설정 함수에 전달해야 함
- 이를 위해 state의 원본 배열을 변경시키지 않는 `filter()`와 `map()` 같은 함수를 사용하여 원본 배열로부터 새 배열을 만들 수 있음
- 이후 이 새 배열들을 state에 설정

**💡 `slice` vs `splice`**
- `slice`를 사용하면 배열 또는 그 일부를 복사할 수 있음
- `splice`는 배열을 변경 (항목을 추가하거나 제거)
- React에서는, state의 객체나 배열을 변경하지 않는 게 좋기 때문에 `slice`를 훨씬 더 자주 사용

<br>

#### 배열에 항목 추가하기
- 기존에 존재하던 항목들 뒤에 새 항목을 포함하는 새로운 배열 생성
- 가장 쉬운 방법은 `...` 배열 전개 구문을 사용하는 것
```javascript
setArtists( // 아래의 새로운 배열로 state를 변경합니다.
  [
    ...artists, // 기존 배열의 모든 항목에,
    { id: nextId++, name: name } // 마지막에 새 항목을 추가합니다.
  ]
);
```

<br>

#### 배열에서 항목 제거하기
- 배열에서 항목을 제거하는 가장 쉬운 방법은 필터링하는 것
- 즉, 해당 항목을 포함하지 않는 새 배열을 제공하는 것 - `filter()` 사용
```javascript
setArtists(
  artists.filter(a => a.id !== artist.id)
);
```

<br>

#### 배열 변환하기
- 배열의 일부 또는 전체 항목을 변경하고자 한다면 `map()`을 사용해 새로운 배열을 만들 수 있음
- `map`에 전달할 함수는 데이터나 인덱스(또는 둘 다)를 기반으로 각 항목을 어떻게 처리할지 결정할 수 있음
```javascript
const nextCounters = counters.map((c, i) => {
  if (i === index) {
    // 클릭된 counter를 증가시킵니다.
    return c + 1;
  } else {
    // 변경되지 않은 나머지를 반환합니다.
    return c;
  }
});
```

<br>

#### 배열에 항목 삽입하기
- 시작도, 끝도 아닌 위치에 항목을 삽입하고 싶을 때에는, `...` 배열 전개 구문과 `slice()` 함수를 함께 사용
- `slice()` 함수를 사용하면 배열의 “**일부분**”을 잘라낼 수 있음
- 항목을 삽입하려면 삽입 지점 앞에 자른 배열을 전개하고, 새 항목과 원본 배열의 나머지 부분을 전개하는 배열을 만듬
```javascript
const nextArtists = [
  // 삽입 지점 이전 항목
  ...artists.slice(0, insertAt),
  // 새 항목
  { id: nextId++, name: name },
  // 삽입 지점 이후 항목
  ...artists.slice(insertAt)
];
```

<br>

#### 배열에 기타 변경 적용하기
- 비-변경 함수들만으로는 할 수 없는 일을 하고 싶을 때 (배열을 뒤집거나 정렬하는 일) -> **배열을 복사한 뒤 변경**
```javascript
function handleClick() {
    const nextList = [...list];
    nextList.reverse();
    setList(nextList);
}
```

- 그러나, 배열을 복사하더라도 배열 내부에 기존 항목을 **직접 변경해서는 안됨**
- **얕은 복사**이기 때문에 복사한 새 배열에는 원본 배열과 동일한 항목이 포함됨
- 따라서, 복사된 배열 내부의 객체를 수정하면 기존 state가 변경됨

<br>

#### 배열 내부의 객체 업데이트하기
- 중첩된 state를 업데이트할 때, 업데이트하려는 지점부터 **최상위 레벨까지의 복사본**을 만들어야 함
- `map`을 사용하면 이전 항목의 변경 없이 업데이트된 버전으로 대체 가능
- 일반적으로 방금 생성한 객체만 변경해야 함
```javascript
setMyList(myList.map(artwork => {
  if (artwork.id === artworkId) {
    // 변경된 *새* 객체를 만들어 반환합니다.
    return { ...artwork, seen: nextSeen };
  } else {
    // 변경시키지 않고 반환합니다.
    return artwork;
  }
}));
```

<br>

#### Immer로 간결한 업데이트 로직 작성하기
- state 구조를 변경하고 싶지 않다면, **Immer**를 사용할 수 있음
- 이는 원본 state를 변경하는 것이 아니라, Immer에서 제공하는 특수 `draft` 객체를 변경
- 마찬가지로 `push()`와 `pop()`같은 변경 함수들도 `draft`의 컨텐츠에 적용 가능
- 내부적으로 Immer는 항상 `draft`에서 수행한 변경 사항에 따라 처음부터 **다음 state를 구성**
- 이렇게 하면 state를 변경하지 않고도 **이벤트 핸들러를 매우 간결하게 유지**할 수 있음!!
```javascript
const [myList, updateMyList] = useImmer(
    initialList
);
```